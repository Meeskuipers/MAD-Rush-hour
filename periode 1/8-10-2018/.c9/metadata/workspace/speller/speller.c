{"changed":true,"filter":false,"title":"speller.c","tooltip":"~/workspace/speller/speller.c","value":"// Implements a spell-checker\n\n#include <ctype.h>\n#include <stdio.h>\n#include <sys/resource.h>\n#include <sys/time.h>\n\n#include \"dictionary.h\"\n\n// Undefine any definitions\n#undef calculate\n#undef getrusage\n\n// Default dictionary\n#define DICTIONARY \"dictionaries/large\"\n\n// Prototype\ndouble calculate(const struct rusage *b, const struct rusage *a);\n\nint main(int argc, char *argv[])\n{\n    // Check for correct number of args\n    if (argc != 2 && argc != 3)\n    {\n        printf(\"Usage: speller [dictionary] text\\n\");\n        return 1;\n    }\n\n    // Structures for timing data\n    struct rusage before, after;\n\n    // Benchmarks\n    double time_load = 0.0, time_check = 0.0, time_size = 0.0, time_unload = 0.0;\n\n    // Determine dictionary to use\n    char *dictionary = (argc == 3) ? argv[1] : DICTIONARY;\n\n    // Load dictionary\n    getrusage(RUSAGE_SELF, &before);\n    bool loaded = load(dictionary);\n    getrusage(RUSAGE_SELF, &after);\n\n    // Exit if dictionary not loaded\n    if (!loaded)\n    {\n        printf(\"Could not load %s.\\n\", dictionary);\n        return 1;\n    }\n\n    // Calculate time to load dictionary\n    time_load = calculate(&before, &after);\n\n    // Try to open text\n    char *text = (argc == 3) ? argv[2] : argv[1];\n    FILE *file = fopen(text, \"r\");\n    if (file == NULL)\n    {\n        printf(\"Could not open %s.\\n\", text);\n        unload();\n        return 1;\n    }\n\n    // Prepare to report misspellings\n    printf(\"\\nMISSPELLED WORDS\\n\\n\");\n\n    // Prepare to spell-check\n    int index = 0, misspellings = 0, words = 0;\n    char word[LENGTH + 1];\n\n    // Spell-check each word in text\n    for (int c = fgetc(file); c != EOF; c = fgetc(file))\n    {\n        // Allow only alphabetical characters and apostrophes\n        if (isalpha(c) || (c == '\\'' && index > 0)) \n        {\n            // Append character to word\n            word[index] = c;\n            index++;\n\n            // Ignore alphabetical strings too long to be words\n            if (index > LENGTH)\n            {\n                // Consume remainder of alphabetical string\n                while ((c = fgetc(file)) != EOF && isalpha(c));\n\n                // Prepare for new word\n                index = 0;\n            }\n        }\n\n        // Ignore words with numbers (like MS Word can)\n        else if (isdigit(c))\n        {\n            // Consume remainder of alphanumeric string\n            while ((c = fgetc(file)) != EOF && isalnum(c));\n\n            // Prepare for new word\n            index = 0;\n        }\n\n        // We must have found a whole word\n        else if (index > 0)\n        {\n            // Terminate current word\n            word[index] = '\\0';\n\n            // Update counter\n            words++;\n\n            // Check word's spelling\n            getrusage(RUSAGE_SELF, &before);\n            bool misspelled = !check(word);\n            getrusage(RUSAGE_SELF, &after);\n\n            // Update benchmark\n            time_check += calculate(&before, &after);\n\n            // Print word if misspelled\n            if (misspelled)\n            {\n                printf(\"%s\\n\", word);\n                misspellings++;\n            }\n\n            // Prepare for next word\n            index = 0;\n        }\n    }\n\n    // Check whether there was an error\n    if (ferror(file))\n    {\n        fclose(file);\n        printf(\"Error reading %s.\\n\", text);\n        unload();\n        return 1;\n    }\n\n    // Close text\n    fclose(file);\n\n    // Determine dictionary's size\n    getrusage(RUSAGE_SELF, &before);\n    unsigned int n = size();\n    getrusage(RUSAGE_SELF, &after);\n\n    // Calculate time to determine dictionary's size\n    time_size = calculate(&before, &after);\n\n    // Unload dictionary\n    getrusage(RUSAGE_SELF, &before);\n    bool unloaded = unload();\n    getrusage(RUSAGE_SELF, &after);\n\n    // Abort if dictionary not unloaded\n    if (!unloaded)\n    {\n        printf(\"Could not unload %s.\\n\", dictionary);\n        return 1;\n    }\n\n    // Calculate time to unload dictionary\n    time_unload = calculate(&before, &after);\n\n    // Report benchmarks\n    printf(\"\\nWORDS MISSPELLED:     %d\\n\", misspellings);\n    printf(\"WORDS IN DICTIONARY:  %d\\n\", n);\n    printf(\"WORDS IN TEXT:        %d\\n\", words);\n    printf(\"TIME IN load:         %.2f\\n\", time_load);\n    printf(\"TIME IN check:        %.2f\\n\", time_check);\n    printf(\"TIME IN size:         %.2f\\n\", time_size);\n    printf(\"TIME IN unload:       %.2f\\n\", time_unload);\n    printf(\"TIME IN TOTAL:        %.2f\\n\\n\",\n           time_load + time_check + time_size + time_unload);\n\n    // Success\n    return 0;\n}\n\n// Returns number of seconds between b and a\ndouble calculate(const struct rusage *b, const struct rusage *a)\n{\n    if (b == NULL || a == NULL)\n    {\n        return 0.0;\n    }\n    else\n    {\n        return ((((a->ru_utime.tv_sec * 1000000 + a->ru_utime.tv_usec) -\n                  (b->ru_utime.tv_sec * 1000000 + b->ru_utime.tv_usec)) +\n                 ((a->ru_stime.tv_sec * 1000000 + a->ru_stime.tv_usec) -\n                  (b->ru_stime.tv_sec * 1000000 + b->ru_stime.tv_usec)))\n                / 1000000.0);\n    }\n}\n","undoManager":{"mark":-2,"position":6,"stack":[[{"start":{"row":73,"column":51},"end":{"row":73,"column":52},"action":"insert","lines":[" "],"id":2}],[{"start":{"row":73,"column":52},"end":{"row":73,"column":54},"action":"insert","lines":["''"],"id":3}],[{"start":{"row":73,"column":53},"end":{"row":73,"column":54},"action":"insert","lines":["a"],"id":4}],[{"start":{"row":73,"column":53},"end":{"row":73,"column":54},"action":"remove","lines":["a"],"id":5}],[{"start":{"row":73,"column":53},"end":{"row":73,"column":54},"action":"insert","lines":["\""],"id":6}],[{"start":{"row":73,"column":53},"end":{"row":73,"column":54},"action":"remove","lines":["\""],"id":7}],[{"start":{"row":73,"column":52},"end":{"row":73,"column":54},"action":"remove","lines":["''"],"id":8}],[{"start":{"row":73,"column":52},"end":{"row":74,"column":0},"action":"remove","lines":["",""],"id":9}]]},"ace":{"folds":[],"scrolltop":2242.5,"scrollleft":0,"selection":{"start":{"row":141,"column":17},"end":{"row":141,"column":27},"isBackwards":false},"options":{"guessTabSize":true,"useWrapMode":false,"wrapToView":true},"firstLineState":{"row":154,"state":"start","mode":"ace/mode/c_cpp"}},"timestamp":1538385922966}